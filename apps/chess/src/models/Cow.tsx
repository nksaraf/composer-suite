/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three"
import React, { ComponentProps, useLayoutEffect, useRef } from "react"
import { Html, useAnimations, useGLTF } from "@react-three/drei"
import { GLTF } from "three-stdlib"
import { AnimationAction, AnimationClip } from "three"
import { useStore } from "statery"
import mergeRefs from "react-merge-refs"
type GLTFResult = GLTF & {
  nodes: {
    Cube: THREE.SkinnedMesh
    Cube_1: THREE.SkinnedMesh
    Cube_2: THREE.SkinnedMesh
    Cube_3: THREE.SkinnedMesh
    Cube_4: THREE.SkinnedMesh
    Cube_5: THREE.SkinnedMesh
    Cube_6: THREE.SkinnedMesh
    Body: THREE.Bone
    IKBackLegL: THREE.Bone
    IKFrontLegL: THREE.Bone
    IKBackLegR: THREE.Bone
    IKFrontLegR: THREE.Bone
  }
  materials: {
    Main: THREE.MeshStandardMaterial
    Main_Light: THREE.MeshStandardMaterial
    Hooves: THREE.MeshStandardMaterial
    Muzzle: THREE.MeshStandardMaterial
    Eye_Black: THREE.MeshStandardMaterial
    Eye_White: THREE.MeshStandardMaterial
    Horns: THREE.MeshStandardMaterial
  }
  animations: { name: ActionName }
}

type ActionName =
  | "Attack_Headbutt"
  | "Attack_Kick"
  | "Death"
  | "Eating"
  | "Gallop"
  | "Gallop_Jump"
  | "Idle"
  | "Idle_2"
  | "Idle_Headlow"
  | "Idle_HitReact_Left"
  | "Idle_HitReact_Right"
  | "Jump_toIdle"
  | "Walk"

interface GLTFActions extends AnimationClip {
  name: ActionName
}

import { Loader } from "three"
import { GroupProps, useFrame, useGraph, useLoader } from "@react-three/fiber"
import { createStateMachine } from "state-composer"
import { createModel } from "../lib/createModel"

function onEnter<T extends string>(
  state: T,
  prevState: T,
  onEnter: { [k in T]?: (prevState: T) => void }
) {
  onEnter[state]?.(prevState)
}

function onExit<T extends string>(
  state: T,
  prevState: T,
  onExit: { [k in T]?: (prevState: T) => void }
) {
  onExit[state]?.(prevState)
}

const state = createStateMachine("idle")

// export function Character() {
//   const { actions, ref } = useAnimations<GLTFActions>(object.animations as any)

//   function getAction(
//     state: ReturnType<typeof useCharacter["getState"]>["state"]
//   ) {
//     return actions[
//       (
//         {
//           idle: "Idle",
//           walk: "Walk",
//           run: "Gallop",
//           attack: "Attack_Headbutt"
//         } as const
//       )[state]
//     ]
//   }

//   useFrame(() => {
//     const { state } = useCharacter.getState()
//     const { controls } = useKeyboardInput.getState()

//     var nextState = state

//     switch (state) {
//       case "idle": {
//         if (controls.forward || controls.backward) {
//           nextState = "walk"
//         }
//         break
//       }
//       case "walk": {
//         if (controls.shift) {
//           nextState = "run"
//         } else if (!controls.forward && !controls.backward) {
//           nextState = "idle"
//         }
//         break
//       }
//       case "run": {
//         if (!controls.shift) {
//           nextState = "walk"
//         }
//         break
//       }
//     }

//     if (nextState != state) {
//       onExit(state, nextState, {})
//       onEnter(nextState, state, {
//         idle: (prevState) => {
//           let idleAction = actions["Idle"]!
//           if (prevState) {
//             idleAction.time = 0
//             idleAction.enabled = true
//             idleAction.setEffectiveWeight(1.0)
//             idleAction.setEffectiveTimeScale(1.0)
//             idleAction?.crossFadeFrom(getAction(prevState)!, 0.5, true)
//             idleAction.play()
//           } else {
//             idleAction.play()
//           }
//         },
//         walk: (prevState) => {
//           let walkAction = actions["Walk"]!
//           walkAction.enabled = true
//           if (prevState === "run") {
//             let runAction = getAction("run")!
//             walkAction.time =
//               runAction.time *
//               (walkAction.getClip().duration / runAction.getClip().duration)
//           } else {
//             walkAction.time = 0.0
//             walkAction.setEffectiveWeight(1.0)
//             walkAction.setEffectiveTimeScale(1.0)
//           }
//           walkAction?.crossFadeFrom(getAction(prevState)!, 0.5, true)
//           walkAction.play()
//         },
//         run: (prevState) => {
//           let runAction = getAction("run")!
//           runAction.enabled = true
//           if (prevState === "walk") {
//             let walkAction = getAction("walk")!
//             runAction.time =
//               walkAction.time *
//               (runAction.getClip().duration / walkAction.getClip().duration)
//           } else {
//             runAction.time = 0.0
//             runAction.setEffectiveWeight(1.0)
//             runAction.setEffectiveTimeScale(1.0)
//           }
//           runAction?.crossFadeFrom(getAction(prevState)!, 0.5, true)
//           runAction.play()
//         }
//       })

//       console.log("transition", state, nextState)
//       useCharacter.setState({ state: nextState })
//     }
//   })

//   return (
//     <>
//       <CowModel
//         ref={ref}
//         gltf={object}
//         position={controls.position}
//         rotation={[0, Math.PI, 0]}
//         onPointerDown={() => {
//           // dispatch({ type: "MOVE" });
//         }}
//       />
//       <Html position={[-15, 2, 6]}>
//         <h1>{state}</h1>
//       </Html>
//     </>
//   )
// }

export const Cow = createModel<GLTFResult>(
  "/animals/Cow.gltf",
  ({ ref, group, nodes, materials, animations, ...props }) => {
    return (
      <group ref={group} {...props} dispose={null}>
        <group name="Scene">
          <group name="AnimalArmature" userData={{ name: "AnimalArmature" }}>
            <primitive object={nodes.Body} />
            <primitive object={nodes.IKBackLegL} />
            <primitive object={nodes.IKFrontLegL} />
            <primitive object={nodes.IKBackLegR} />
            <primitive object={nodes.IKFrontLegR} />
            <group name="Cow" userData={{ name: "Cow" }}>
              <skinnedMesh
                name="Cube"
                geometry={nodes.Cube.geometry}
                material={materials.Main}
                skeleton={nodes.Cube.skeleton}
                castShadow
              />
              <skinnedMesh
                name="Cube_1"
                geometry={nodes.Cube_1.geometry}
                material={materials.Main_Light}
                castShadow
                skeleton={nodes.Cube_1.skeleton}
              />
              <skinnedMesh
                name="Cube_2"
                geometry={nodes.Cube_2.geometry}
                material={materials.Hooves}
                castShadow
                skeleton={nodes.Cube_2.skeleton}
              />
              <skinnedMesh
                name="Cube_3"
                geometry={nodes.Cube_3.geometry}
                castShadow
                material={materials.Muzzle}
                skeleton={nodes.Cube_3.skeleton}
              />
              <skinnedMesh
                name="Cube_4"
                geometry={nodes.Cube_4.geometry}
                castShadow
                material={materials.Eye_Black}
                skeleton={nodes.Cube_4.skeleton}
              />
              <skinnedMesh
                name="Cube_5"
                geometry={nodes.Cube_5.geometry}
                castShadow
                material={materials.Eye_White}
                skeleton={nodes.Cube_5.skeleton}
              />
              <skinnedMesh
                name="Cube_6"
                geometry={nodes.Cube_6.geometry}
                castShadow
                material={materials.Horns}
                skeleton={nodes.Cube_6.skeleton}
              />
            </group>
          </group>
        </group>
        {props.children}
      </group>
    )
  }
)

// export const CowModel = React.forwardRef<
//   THREE.Group & { actions: { [key: string]: AnimationAction } }
// >(function CowModel(props: JSX.IntrinsicElements["group"], ref) {})
