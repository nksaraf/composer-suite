/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGLTF } from "@react-three/drei"
import * as THREE from "three"
import { GLTF } from "three-stdlib"
import { BISHOP, BLACK, KING, KNIGHT, PAWN, QUEEN, ROOK } from "~/lib/chess"
import { PieceProps } from "./Board"

type GLTFResult = GLTF & {
  nodes: {
    Rook: THREE.Mesh
    Queen: THREE.Mesh
    Bishop: THREE.Mesh
    King: THREE.Mesh
    Knight: THREE.Mesh
    Pawn: THREE.Mesh
  }
  materials: {
    white_piece: THREE.MeshStandardMaterial
    black_piece: THREE.MeshStandardMaterial
  }
}

const pieceMap = {
  [PAWN]: "Pawn",
  [ROOK]: "Rook",
  [QUEEN]: "Queen",
  [KING]: "King",
  [KNIGHT]: "Knight",
  [BISHOP]: "Bishop"
} as const

export function Piece(props: PieceProps) {
  // const controls = useControls("piece", {
  //   color: folder({ black: "#414141", white: "#c4bdbd" })
  // });

  const controls = { black: "#222222", white: "#c4bdbd" }

  // const object = useTheatreControls("piece", {
  //   y: 0,
  //   rotateY: -Math.PI / 2
  // });

  // const [x, y, z] = position;

  // const ref = React.useRef<THREE.Object3D>();

  // useFrame(() => {});

  // const [isSquareHovered, setIsSquareHovered] = useAtom(
  //   $.isHoveredSquare(square)
  // );

  // const [selectedSquare, setSelectedSquare] = useAtom($.selectedSquare);
  // const isSelected = selectedSquare === square;
  // const [_, bind] = useHover({
  //   onPointerEnter: (e) => {
  //     setIsSquareHovered(true);
  //   },
  //   onPointerLeave: (e) => {
  //     setIsSquareHovered(false);
  //   },
  // });
  // const turn = useAtomValue($.turn);
  // const isSelectable = color === turn;

  // const { spring: hoverSpring } = useSpring({
  //   spring: (isSquareHovered && isSelectable) || isSelected ? 1 : 0,
  //   config: { mass: 5, tension: 400, friction: 50, precision: 0.0001 },
  // });

  // const positionY = hoverSpring.to([0, 1], [y, y + 0.3]);
  // const rotationY = hoverSpring.to([0, 1], [0, 0.5]);

  return (
    <group
      position={props.position}
      // rotation-y={object.rotateY}
    >
      <PieceModel
        // {...bind}
        piece={pieceMap[props.piece]}
        onPointerDown={() => {
          // if (color === turn) {
          //   setSelectedSquare(square);
          // }
        }}
        rotation={[
          -Math.PI / 4,
          0,
          0
          // props.color === BLACK ? (5 / 4) * Math.PI : Math.PI / 4
        ]}
        // material={props.color === BLACK ? "black_piece" : "white_piece"}
        // {...props}
      >
        <meshLambertMaterial
          reflectivity={10}
          color={props.color === BLACK ? controls.black : controls.white}
        />
      </PieceModel>
    </group>
  )
}

type PieceType = keyof GLTFResult["nodes"]

export function PieceModel(
  props: JSX.IntrinsicElements["group"] & {
    piece: PieceType
    material?: keyof GLTFResult["materials"]
  }
) {
  // const group = THREE.Group!;
  const { nodes, materials } = useGLTF(
    "/models/low_poly_chess_set/pieces.glb"
  ) as unknown as GLTFResult

  return (
    <group {...props}>
      <group name="Piece">
        <mesh
          name={props.piece}
          castShadow
          receiveShadow
          rotation={props.rotation}
          geometry={nodes[props.piece].geometry}
          {...(props.material ? { material: materials[props.material] } : {})}
          userData={{ name: props.piece }}
        >
          {props.children}
        </mesh>
      </group>
    </group>
  )
}

// useGLTF.preload("/low_poly_chess_set/pieces.glb");
